import React, { useState, useEffect, useCallback } from "react";
import * as d3 from 'd3';
import useWindowDimensions from '../helpers/userWindowDimensions'

// import "./HeatMap.scss";

export default function HeatMap(props) {
  const { height, width } = useWindowDimensions();
  const [data, setData] = useState({
    base: 0,
    albumCount: [
    ]
  })

  let xScale;
  let yScale;

  let minYear;
  let maxYear;

  let padding = width / 10;

  let graphWidth = width / 1.3
  let graphHeight = height / 1.3

  let canvas = d3.select('#canvas')
  canvas.attr('width', graphWidth)
  canvas.attr('height', graphHeight)

  useEffect(() => {
    // Combine all artists from the two queries
    const allArtists = [...props.dataGraphFirst.topTrackOffset, ...props.dataGraphSecond.topTrackOffset]

    // Create an array of the year and month of each release data
    const allAlbumDates = [];
    allArtists.forEach((artist) => {
      allAlbumDates.push(artist.album.release_date.slice(0, 7))
    })

    // From the release dates, find the count of each
    // eg. number of times 1982-02 appears
    // create an object of the month/year and the count
    const countOccurrences = arr => arr.reduce((prev, curr) => (prev[curr] = ++prev[curr] || 1, prev), {});
    const eachOccurence = countOccurrences(allAlbumDates)

    console.log("each", eachOccurence)

    // Data format for graph
    // Base is number of albums for that month/year
    // And array of each month/year in the
    const dateData = {
      base: 0,
      albumCount: [
        // {
          // year:
          // month:
          // count:
        // }
      ]
    }

    // For each item in the object, create an object of
    // the year, month, and count to push into albumCount
    // Some albums don't have release months, so choose 1
    for (const album in eachOccurence) {
      const obj = {};
      obj.year = Number(album.slice(0, 4))
      obj.month = Number("" === album.slice(5, 7) ? 1 : album.slice(5, 7))
      obj.count = Number(eachOccurence[album])
      dateData.albumCount.push(obj)
    }

    setData(dateData)
  }, [props.dataGraphFirst, props.dataGraphSecond])

  const createChart = () => {

    console.log("hello")
    // Find the minimum year in our data
    minYear = d3.min(data.albumCount, (item) => {
      return item['year']
    })

    // Find the maximum year in our data
    maxYear = d3.max(data.albumCount, (item) => {
      return item['year']
    })

    // x-axis scale
    xScale = d3.scaleLinear()
              .domain([minYear, maxYear + 1])
              .range([padding, graphWidth - padding])

    // y-axis scale
    yScale = d3.scaleTime()
              .domain([new Date(0, 0, 0, 0, 0, 0, 0), new Date(0, 12, 0, 0, 0, 0, 0)])
              .range([padding, graphHeight - padding])

    console.log("howdy")
    // Each rectangle generated by data
    canvas.selectAll('rect')
          .data(data.albumCount)
          .enter()
          .append('rect')
          .attr('class', 'cell')
          .attr('fill', (item) => {
            const albumCount = item['count']
            if (albumCount === 0) {
              // return '#D6F2C1'
            } else if (albumCount === 1) {
              return '#CBF4AD'
            } else if (albumCount === 2) {
              return '#B3F783'
            } else if (albumCount === 3) {
              return '#95F952'
            } else if (albumCount === 4) {
              return '#66FC02'
            } else if (albumCount === 5) {
              return '#53EA02'
            } else if (albumCount === 6) {
              return '#45CC02'
            } else if (albumCount === 7) {
              return '#39A801'
            } else if (albumCount > 8) {
              return '#306B00'
            }
          })
          .attr('data-year', (item) => {
            return item['year']
          })
          .attr('data-month', (item) => {
            return item['month'] - 1
          })
          .attr('data', (item) => {
            return item['albumCount']
          })
          .attr('height', `${(graphHeight - (padding * 2)) / 12}`)
          .attr('y', (item) => {
            return yScale(new Date(0, item['month'] - 1, 0, 0, 0, 0, 0 ))
          })
          .attr('width', (item) => {
            let numberOfYears = maxYear - minYear
            return (graphWidth - (padding * 2)) / numberOfYears
          })
          .attr('x', (item) => {
            return xScale(item['year'])
          })

    console.log("maybe")
    let xAxis = d3.axisBottom(xScale)
                  .tickFormat(d3.format('d'))

    let yAxis = d3.axisLeft(yScale)
                  .tickFormat(d3.timeFormat('%B'))

    canvas.append('g')
          .call(xAxis)
          .attr('id', 'x-axis')
          .attr('transform', `translate(0, ${graphHeight - padding})`)

    canvas.append('g')
          .call(yAxis)
          .attr('id', 'y-axis')
          .attr('transform', `translate(${padding}, 0)`)
  }

  return (
    <>
      <br/>
      {data && createChart()}
      <svg id="canvas">
      </svg>
    </>
  );
}
